# x86_64 架构实现

本系统针对 x86_64 架构进行了专门的实现，包括启动过程、内存管理、中断处理等方面。

## 架构概述

x86_64 是 64 位的 x86 架构处理器，具有以下特点：

* 64 位寄存器和寻址能力
* 多级页表（PML4, PDPT, PD, PT）
* 支持长模式（64 位模式）
* 扩展的指令集
* 更多的通用寄存器

## 启动过程

### 1. 实模式到保护模式的切换

系统启动时，处理器首先进入实模式，然后通过以下步骤切换到长模式：

1. **初始化段寄存器**：设置段寄存器的值
2. **加载页表**：设置 CR3 寄存器指向 PML4 表
3. **加载 GDT**：加载全局描述符表
4. **加载 IDT**：加载中断描述符表
5. **切换到长模式**：通过远跳转切换到 64 位模式

### 2. 长模式初始化

在 `head.S` 中，系统完成长模式的初始化：

```assembly
// 加载 CR3
movq $0x101000, %rax
movq %rax, %cr3

// 加载 GDT
lgdt GDT_POINTER(%rip)

// 加载 IDT
lidt IDT_POINTER(%rip)

// 切换到长模式
movq switch_seg(%rip), %rax
pushq $0x08
pushq %rax
lretq
```

### 3. 内核入口

系统切换到长模式后，调用 `kernel_main` 函数：

```assembly
// 调用 kernel_main
movq BOOT_INFO(%rip), %rax
movq %rax, %rdi
movq go_to_kernel(%rip), %rax
pushq $0x08
pushq %rax
lretq

go_to_kernel:
    .quad kernel_main
```

## 内存管理

### 1. 页表结构

x86_64 架构使用四级页表：

* **PML4**（Page Map Level 4）：最高级页表
* **PDPT**（Page Directory Pointer Table）：页目录指针表
* **PD**（Page Directory）：页目录
* **PT**（Page Table）：页表

### 2. 初始页表

在 `head.S` 中，系统定义了初始页表：

```assembly
.org 0x1000

__PML4E:
    .quad 0x102003
    .fill 255,8,0
    .quad 0x102003
    .fill 255,8,0

.org 0x2000

__PDPTE:
    .quad 0x103003
    .fill 511,8,0

.org 0x3000

__PDE:
    .quad 0x000083
    .quad 0x200083
    .quad 0x400083
    .quad 0x600083
    .quad 0x800083
    .quad 0xa00083
    .quad 0xc00083
    .quad 0xe00083
    .quad 0x1000083
    .quad 0x1200083
    .quad 0x1400083
    .quad 0x1600083
    .quad 0x1800083
    .quad 0x1a00083
    .quad 0x1c00083
    .quad 0x1e00083
    .fill 496,8,0
```

### 3. 虚拟地址空间

系统使用以下虚拟地址空间布局：

* **内核空间**：从 0xffff800000000000 开始
* **用户空间**：从 0x0000000000000000 到 0x00007fffffffffff

### 4. 物理地址和虚拟地址转换

系统提供了以下函数进行地址转换：

* `Phy_To_Virt`：将物理地址转换为虚拟地址
* `Virt_To_Phy`：将虚拟地址转换为物理地址

## 中断处理

### 1. 中断描述符表（IDT）

系统使用中断描述符表（IDT）来管理中断处理函数。在 `head.S` 中，系统初始化 IDT：

```assembly
setup_IDT:
    leaq ignore_int(%rip), %rdx
    movq $(0x08 << 16), %rax
    movw %dx, %ax
    movq $(0x8e00 << 32), %rcx
    addq %rcx, %rax
    movl %edx, %ecx
    shrl $16, %ecx
    shlq $48, %rcx
    addq %rcx, %rax
    shrq $32, %rdx
    leaq IDT_Table(%rip), %rdi
    mov $256, %rcx
rp_sidt:
    movq %rax, (%rdi)
    movq %rdx, 8(%rdi)
    addq $0x10, %rdi
    dec %rcx
    jne rp_sidt
```

### 2. 中断门设置

系统提供了以下函数设置中断门：

* `set_intr_gate`：设置中断门
* `set_trap_gate`：设置陷阱门
* `set_system_gate`：设置系统门

### 3. 中断处理函数

系统实现了各种中断处理函数，包括：

* 处理器异常处理（如除零错误、页错误等）
* 外部设备中断处理（如键盘、定时器等）

### 4. 中断堆栈

系统为中断处理设置了专门的堆栈，确保中断处理过程中的堆栈安全。

## 硬件访问

### 1. I/O 端口访问

系统提供了以下函数进行 I/O 端口访问：

* `inb`：从 8 位端口读取数据
* `outb`：向 8 位端口写入数据
* `inw`：从 16 位端口读取数据
* `outw`：向 16 位端口写入数据
* `inl`：从 32 位端口读取数据
* `outl`：向 32 位端口写入数据

### 2. 特殊寄存器访问

系统提供了以下函数访问特殊寄存器：

* `rdmsr`：读取模型特定寄存器
* `wrmsr`：写入模型特定寄存器
* `rdtsc`：读取时间戳计数器

### 3. 内存屏障

系统提供了内存屏障指令，确保内存操作的顺序：

* `mfence`：内存屏障
* `lfence`：加载屏障
* `sfence`：存储屏障

## 同步原语

### 1. 自旋锁

系统实现了自旋锁，用于多处理器环境下的同步：

```c
typedef struct spinlock {
    volatile uint32_t lock;
} spinlock_t;

void spin_init(spinlock_t *lock);
void spin_lock(spinlock_t *lock);
void spin_unlock(spinlock_t *lock);
bool spin_trylock(spinlock_t *lock);
```

### 2. 原子操作

系统实现了各种原子操作，用于无锁编程：

* `atomic_add`：原子加法
* `atomic_sub`：原子减法
* `atomic_and`：原子与操作
* `atomic_or`：原子或操作
* `atomic_xchg`：原子交换

## 代码结构

### 1. 汇编文件

* `head.S` - 系统启动和初始化
* `entry.S` - 中断入口点

### 2. C 文件

* `trap.c` - 陷阱处理

### 3. 头文件

* `asm.h` - 汇编相关定义
* `gate.h` - 门描述符相关定义
* `hw.h` - 硬件访问相关定义
* `linkage.h` - 链接相关定义
* `regs.h` - 寄存器相关定义
* `spinlock.h` - 自旋锁相关定义
* `trap.h` - 陷阱相关定义

### 4. 链接脚本

* `linker.ld` - 链接脚本，定义内存布局

## 启动流程详解

### 1. 处理器复位

1. 处理器复位，进入实模式
2. 执行 BIOS/UEFI 初始化
3. 加载引导程序
4. 引导程序加载内核

### 2. 内核初始化

1. **实模式初始化**：设置段寄存器，准备进入保护模式
2. **保护模式初始化**：加载 GDT，设置分页
3. **长模式初始化**：启用 PAE，设置长模式页表，切换到长模式
4. **内核初始化**：调用 `kernel_main` 函数

### 3. `kernel_main` 函数

`kernel_main` 函数是内核的主入口点，执行以下操作：

1. **初始化帧缓冲区**：设置图形显示
2. **加载任务寄存器**：设置 TSS
3. **初始化中断**：安装系统向量和 IRQ
4. **初始化串口**：设置串口调试输出
5. **初始化内存管理**：检测内存，初始化物理内存和虚拟内存
6. **初始化驱动**：初始化 PIC、定时器、键盘等
7. **创建定时器**：创建测试定时器
8. **进入主循环**：执行 hlt 指令，等待中断

## 内存布局

### 1. 物理内存布局

* **低内存**：0x00000000 到 0x000fffff，包含 BIOS 数据和中断向量表
* **内核代码**：从某个物理地址开始，包含内核代码和数据
* **可用内存**：其他物理内存区域

### 2. 虚拟内存布局

* **内核空间**：0xffff800000000000 到 0xffffffffffffffff
  * 内核代码和数据
  * 物理内存映射
  * 设备内存映射
* **用户空间**：0x0000000000000000 到 0x00007fffffffffff
  * 用户代码和数据
  * 堆
  * 栈

## 中断处理流程

### 1. 外部中断处理

1. 外部设备触发中断
2. PIC/APIC 接收中断信号
3. 处理器响应中断，保存现场
4. 跳转到对应的中断处理函数
5. 处理中断
6. 发送 EOI 信号
7. 恢复现场，返回中断点

### 2. 处理器异常处理

1. 处理器检测到异常
2. 保存现场
3. 跳转到对应的异常处理函数
4. 处理异常
5. 恢复现场，返回异常点或终止程序

## 性能优化

### 1. 内存访问优化

* **大页面使用**：使用 2MB 大页面减少页表层级
* **内存对齐**：确保数据结构对齐，提高内存访问速度
* **缓存优化**：合理安排数据结构，提高缓存命中率

### 2. 中断处理优化

* **中断处理函数轻量化**：减少中断处理函数的执行时间
* **软中断使用**：将耗时操作移到软中断中处理
* **中断亲和性**：合理分配中断到不同的处理器核心

### 3. 指令优化

* **使用 64 位指令**：充分利用 64 位指令集的优势
* **指令调度**：合理安排指令顺序，减少流水线停顿
* **避免分支预测失败**：减少分支预测失败的概率

## 扩展架构支持

### 1. 多处理器支持

系统可以通过以下方式扩展对多处理器的支持：

* **APIC 支持**：实现 APIC 控制器的初始化和管理
* **处理器启动**：实现 APs（应用处理器）的启动
* **调度器**：实现多处理器调度器

### 2. 高级功能支持

系统可以扩展支持以下高级功能：

* **SSE/AVX 指令集**：支持高级向量扩展指令
* **PAE/NX**：支持物理地址扩展和执行禁用
* **TSC 校准**：校准时间戳计数器
* **MSR 访问**：访问模型特定寄存器

## 调试技巧

### 1. 串口调试

系统使用串口进行调试输出：

```c
serial_printk("Debug message: %x\n", value);
```

### 2. 断点调试

系统支持使用 int3 指令设置断点：

```c
__asm__ __volatile__("int3");
```

### 3. 堆栈跟踪

系统提供了堆栈跟踪功能，用于调试崩溃：

```c
backtrace(regs);
```

### 4. 内存转储

系统提供了内存转储功能，用于调试内存问题：

```c
mem_dump(address, length);
```

## 注意事项

1. **内存对齐**：x86_64 架构要求某些数据结构必须对齐，否则会导致性能下降或错误
2. **页表管理**：页表管理是系统稳定性的关键，需要仔细实现
3. **中断处理**：中断处理函数必须正确保存和恢复现场，否则会导致系统崩溃
4. **硬件访问**：硬件访问必须遵循正确的时序和协议，否则会导致硬件损坏
5. **同步**：多处理器环境下的同步是一个复杂的问题，需要仔细设计

## 总结

本系统针对 x86_64 架构进行了全面的实现，包括：

1. **启动过程**：从实模式到长模式的完整切换
2. **内存管理**：多级页表和虚拟内存
3. **中断处理**：完整的中断处理系统
4. **硬件访问**：各种硬件访问接口
5. **同步原语**：自旋锁和原子操作

这些实现为系统提供了稳定、高效的运行环境，同时也为后续的功能扩展奠定了基础。